<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>spearhead</title><link href="http://blog.sitongpeng.com/" rel="alternate"></link><link href="http://blog.sitongpeng.com/feeds/misc.atom.xml" rel="self"></link><id>http://blog.sitongpeng.com/</id><updated>2014-01-18T08:30:00-08:00</updated><entry><title>The Self Aware Python Function</title><link href="http://blog.sitongpeng.com/posts/the-self-aware-python-function.html" rel="alternate"></link><updated>2014-01-18T08:30:00-08:00</updated><author><name>Sitong Peng</name></author><id>tag:blog.sitongpeng.com,2014-01-18:posts/the-self-aware-python-function.html</id><summary type="html">&lt;p&gt;I've been using Python for over a year now. It's what I learned to program with. About half a year ago, a fellow coder (friend of a friend) posed the following riddle upon learning that it was my language of choice:&lt;/p&gt;
&lt;p class="quote"&gt;"How would you write a function in Python that knows how many times it's been invoked?"&lt;/p&gt;

&lt;p&gt;Let's consider this for a moment. A function that knows how many times it has been invoked is one that would need some access to a scope outside of it's own. Functions are generally pretty transient &amp;mdash; they do their thing and then wait until they are told to do it again. There isn't a middling dormant state where they consider how many times they've been told to execute their (probably) menial task.&lt;/p&gt;
&lt;p&gt;As a first stab, we might consider a global counter, as in the following setup:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;self_aware_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;This is my first time doing this&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;I have done this {} times now.&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;self_aware_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Those familiar with Python are up in arms right now, and rightfully so. Here's what you get when invoking &lt;code&gt;self_aware_function&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;UnboundLocalError&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;count&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;referenced&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="n"&gt;assignment&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In Python, when you are in a function and assign a value to an immutable type variable (such as our int &lt;code&gt;count&lt;/code&gt;), you end up shadowing the global variable with one local to the function's scope. So when &lt;code&gt;count += 1&lt;/code&gt; is evaluated (remember this is expanded to &lt;code&gt;count = count + 1&lt;/code&gt;), Python cannot find the value for &lt;code&gt;count&lt;/code&gt; in the expression to the right of the &lt;code&gt;=&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Okay, local variables won't work, how about we use the &lt;code&gt;global&lt;/code&gt; keyword or mutable variables?&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# global keyword&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;self_aware_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="c"&gt;# Now we force the use of the global count&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="c"&gt;# ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# using a list&lt;/span&gt;
&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;self_aware_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="c"&gt;# ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;These both work and globals were my first idea for a solution. However, when I asked if this was acceptable, I was met with opposition.&lt;/p&gt;
&lt;p class="quote"&gt;"You are only allowed to write code within the function, not outside of it."&lt;/p&gt;

&lt;p&gt;That's rough. How do you become self aware of an outside world/scope that you can't even interact with?&lt;/p&gt;
&lt;p&gt;Turns out, the answer lies within a popular Python &lt;a href="http://effbot.org/zone/default-values.html"&gt;gotcha&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Self-awareness&lt;/h2&gt;
&lt;p&gt;Here's how you define a default parameter in Python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In Python, default parameters are evaluated ONLY once &amp;mdash; when the function is defined. That means the default parameter is "the same" for all invocations of the function. I say "the same" because normally the default parameter will have the same value across multiple function invocations, but if your default parameter is mutable then you change it! And then you can do some really special things.&lt;/p&gt;
&lt;p&gt;Case in point, self-awareness:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;self_aware_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]):&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;This is my first time doing this&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Who are you to tell me what to do???&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;I have done this {} times now.&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;self_aware_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt; is evaluated at function definition to be a mutable list with one integer element.&lt;/li&gt;
&lt;li&gt;Each invocation of our &lt;code&gt;self_aware_function&lt;/code&gt; adds another tick to our mutable &lt;code&gt;count&lt;/code&gt; parameter.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And we have our cheeky, self aware function!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;python aware.py
This is my first &lt;span class="nb"&gt;time &lt;/span&gt;doing this
I have &lt;span class="k"&gt;done &lt;/span&gt;this 2 &lt;span class="nb"&gt;times &lt;/span&gt;now.
I have &lt;span class="k"&gt;done &lt;/span&gt;this 3 &lt;span class="nb"&gt;times &lt;/span&gt;now.
I have &lt;span class="k"&gt;done &lt;/span&gt;this 4 &lt;span class="nb"&gt;times &lt;/span&gt;now.
I have &lt;span class="k"&gt;done &lt;/span&gt;this 5 &lt;span class="nb"&gt;times &lt;/span&gt;now.
I have &lt;span class="k"&gt;done &lt;/span&gt;this 6 &lt;span class="nb"&gt;times &lt;/span&gt;now.
I have &lt;span class="k"&gt;done &lt;/span&gt;this 7 &lt;span class="nb"&gt;times &lt;/span&gt;now.
I have &lt;span class="k"&gt;done &lt;/span&gt;this 8 &lt;span class="nb"&gt;times &lt;/span&gt;now.
I have &lt;span class="k"&gt;done &lt;/span&gt;this 9 &lt;span class="nb"&gt;times &lt;/span&gt;now.
Who are you to tell me what to &lt;span class="k"&gt;do&lt;/span&gt;???
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span class="note"&gt;If you're wondering, mutable default arguments was the answer I gave after a good amount of thought. I believe there are other solutions and I invite you to share them in the comments :)&lt;/span&gt;&lt;/p&gt;</summary><category term="python"></category></entry></feed>